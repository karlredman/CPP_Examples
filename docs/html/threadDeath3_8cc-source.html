<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Various C++ Examples (including IPC): threadDeath3.cc Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.5 -->
<div class="qindex">  <form class="search" action="search.php" method="get">
<a class="qindex" href="main.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="classes.html">Alphabetical&nbsp;List</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a> | <a class="qindex" href="globals.html">File&nbsp;Members</a> | <a class="qindex" href="pages.html">Related&nbsp;Pages</a>  | <span class="search"><u>S</u>earch&nbsp;for&nbsp;<input class="search" type="text" name="query" value="" size="20" accesskey="s"/></span></form></div>
<h1>threadDeath3.cc</h1><a href="threadDeath3_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 
00025 <span class="preprocessor">#include &lt;iostream&gt;</span>
00026 <span class="preprocessor">#include &lt;stack&gt;</span>
00027 <span class="preprocessor">#include &lt;map&gt;</span>
00028 <span class="preprocessor">#include &lt;algorithm&gt;</span>
00029 <span class="preprocessor">#include &lt;string&gt;</span>
00030 <span class="preprocessor">#include &lt;pthread.h&gt;</span>
00031 
<a name="l00060"></a><a class="code" href="classThreadMgr.html">00060</a> <span class="keyword">class </span><a class="code" href="classThreadMgr.html">ThreadMgr</a> {
00061 <span class="keyword">private</span>:
<a name="l00063"></a><a class="code" href="structThreadMgr_1_1func__arguments.html">00063</a>   <span class="keyword">struct </span><a class="code" href="structThreadMgr_1_1func__arguments.html">func_arguments</a>
00064   {
00066     <span class="keywordtype">void</span> *(*func)(<span class="keywordtype">void</span> *);
00067 
00069     void (*<a class="code" href="structThreadMgr_1_1func__arguments.html#o1">cancel_func</a>)(<span class="keywordtype">void</span> *);
00070 
<a name="l00072"></a><a class="code" href="structThreadMgr_1_1func__arguments.html#o2">00072</a>     <span class="keywordtype">void</span> *<a class="code" href="structThreadMgr_1_1func__arguments.html#o2">arg</a>;
00073 
<a name="l00075"></a><a class="code" href="structThreadMgr_1_1func__arguments.html#o3">00075</a>     <a class="code" href="classThreadMgr.html">ThreadMgr</a> *<a class="code" href="structThreadMgr_1_1func__arguments.html#o3">thisObject</a>;      
00076   };
00077   
00078 <span class="keyword">public</span>:
<a name="l00080"></a><a class="code" href="classThreadMgr.html#a0">00080</a>   <a class="code" href="classThreadMgr.html#a0">ThreadMgr</a>() 
00081   { 
00086     <span class="comment">//the data mutex</span>
00087     <span class="keyword">static</span> pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; 
00088     <a class="code" href="classThreadMgr.html#r0">m_mutex</a> = &amp;mutex; 
00089 
00090     <span class="comment">//the condition variable mutex</span>
00091     <span class="keyword">static</span> pthread_mutex_t cond_mutex = PTHREAD_MUTEX_INITIALIZER;
00092     <a class="code" href="classThreadMgr.html#r1">m_cond_mutex</a> = &amp;cond_mutex;
00093 
00094     <span class="comment">//the condition variable</span>
00095     <span class="keyword">static</span> pthread_cond_t cond_var = PTHREAD_COND_INITIALIZER;
00096     <a class="code" href="classThreadMgr.html#r2">m_cond_var</a> = &amp;cond_var;
00097   }
00098 
<a name="l00100"></a><a class="code" href="classThreadMgr.html#a1">00100</a>   <span class="keywordtype">int</span> <a class="code" href="classThreadMgr.html#a1">cancel_thread</a>(pthread_t *tid)
00101   {
00126     <span class="comment">//cancel a thread</span>
00127     <span class="keywordtype">int</span> ret = 0;
00128     pthread_mutex_lock(<a class="code" href="classThreadMgr.html#r0">m_mutex</a>);        <span class="comment">//lock the data mutex </span>
00129     <a class="code" href="classThreadMgr.html#r3">m_ids</a>.erase(*tid);                  <span class="comment">//remove from id map</span>
00130 
00131     <span class="comment">//cancel the thread</span>
00132     ret = pthread_cancel(*tid);
00133     
00134     pthread_mutex_unlock(<a class="code" href="classThreadMgr.html#r0">m_mutex</a>);      <span class="comment">// unlock data mutex</span>
00135 
00136     <span class="keywordflow">return</span> ret; 
00137   }
00138 
<a name="l00140"></a><a class="code" href="classThreadMgr.html#a2">00140</a>   <span class="keywordtype">int</span> <a class="code" href="classThreadMgr.html#a2">condWait</a>(<span class="keywordtype">void</span> **thread_return_val)
00141   {
00156     <span class="keywordtype">int</span> ret = 0;
00157     
00158     <span class="comment">//condition variable mutex lock</span>
00159     pthread_mutex_lock(<a class="code" href="classThreadMgr.html#r1">m_cond_mutex</a>);
00160 
00161     <span class="comment">//check predicate</span>
00162     <span class="keywordflow">while</span>(<a class="code" href="classThreadMgr.html#a5">no_threads_terminated</a>())
00163       {
00164         <span class="comment">//wait on condition variable</span>
00165         pthread_cond_wait(<a class="code" href="classThreadMgr.html#r2">m_cond_var</a>, <a class="code" href="classThreadMgr.html#r1">m_cond_mutex</a>);
00166       }
00167 
00168 
00169     <span class="comment">//remove the thread from the terminated list (handle join)</span>
00170     ret = <a class="code" href="classThreadMgr.html#b0">removeTerminated</a>(thread_return_val);
00171 
00172     <span class="comment">//unlock</span>
00173     pthread_mutex_unlock(<a class="code" href="classThreadMgr.html#r1">m_cond_mutex</a>);
00174 
00175     <span class="comment">//return join status</span>
00176     <span class="keywordflow">return</span> ret;
00177   }
00178 
00180   <span class="comment">//int createThread( void *(*thread_func)(void *), void *arg)</span>
<a name="l00181"></a><a class="code" href="classThreadMgr.html#a3">00181</a>   pthread_t <a class="code" href="classThreadMgr.html#a3">createThread</a>( <span class="keywordtype">void</span> *(*thread_func)(<span class="keywordtype">void</span> *), <span class="keywordtype">void</span> *arg)
00182   {
00203     pthread_t tid = 0;          <span class="comment">// Id of thread</span>
00204     <span class="keywordtype">int</span> ret_val;                <span class="comment">// return value</span>
00205  
00206     <span class="comment">//arguments for the function</span>
00207     <span class="keyword">struct </span><a class="code" href="structThreadMgr_1_1func__arguments.html">func_arguments</a> *arguments = <span class="keyword">new</span> <a class="code" href="structThreadMgr_1_1func__arguments.html">func_arguments</a>;
00208 
00209     arguments-&gt;func = thread_func;      <span class="comment">// users function</span>
00210     arguments-&gt;cancel_func = NULL;      <span class="comment">// NOT IMPLIMENTED</span>
00211     arguments-&gt;arg = arg;               <span class="comment">// users argument</span>
00212 
00213     <span class="comment">//this is the this pointer (so far, every thread get's one -eek!)</span>
00214     arguments-&gt;thisObject = <span class="keyword">this</span>;
00215 
00216     <span class="comment">//create a new thread</span>
00217     <span class="comment">/*</span>
00218 <span class="comment">      default attributes (for now), </span>
00219 <span class="comment">      internal function, func(), calls users function,</span>
00220 <span class="comment">      arguments contain other info + user's argument.</span>
00221 <span class="comment">    */</span>
00222     ret_val = pthread_create(&amp;tid, (pthread_attr_t *) NULL, <a class="code" href="classThreadMgr.html#f0">func</a>, (<span class="keywordtype">void</span> *)arguments);
00223 
00224     <span class="keywordflow">if</span>(ret_val == 0)
00225       {
00226         <span class="comment">//register the thread and arguments in the ids map</span>
00227         <a class="code" href="classThreadMgr.html#b1">addID</a>(tid, arguments);
00228     
00229         <span class="comment">//return thread id</span>
00230         <span class="keywordflow">return</span> tid;
00231       }
00232     <span class="keywordflow">else</span>
00233       std::cout &lt;&lt; <span class="stringliteral">"pthread_create FAIL"</span> &lt;&lt; std::endl;
00234 
00235 
00236     <span class="comment">//return 0 on error</span>
00237     <span class="keywordflow">return</span> 0;
00238   }
00239   
<a name="l00241"></a><a class="code" href="classThreadMgr.html#a4">00241</a>   <span class="keywordtype">int</span> <a class="code" href="classThreadMgr.html#a4">threadsActive</a>()
00242   { 
00243     pthread_mutex_lock(<a class="code" href="classThreadMgr.html#r0">m_mutex</a>);
00244     <span class="keywordtype">int</span> ret =  <a class="code" href="classThreadMgr.html#r3">m_ids</a>.size(); 
00245     pthread_mutex_unlock(<a class="code" href="classThreadMgr.html#r0">m_mutex</a>);
00246     
00247     <span class="keywordflow">return</span> ret;
00248   }
00249     
<a name="l00251"></a><a class="code" href="classThreadMgr.html#a5">00251</a>   <span class="keywordtype">bool</span> <a class="code" href="classThreadMgr.html#a5">no_threads_terminated</a>()
00252   {
00255     pthread_mutex_lock(<a class="code" href="classThreadMgr.html#r0">m_mutex</a>);
00256     <span class="keywordtype">bool</span> ret = <a class="code" href="classThreadMgr.html#r4">m_terminated</a>.empty();
00257     pthread_mutex_unlock(<a class="code" href="classThreadMgr.html#r0">m_mutex</a>);
00258     <span class="keywordflow">return</span> ret;
00259   }
00260     
00261 
00262 
00263 <span class="keyword">protected</span>:
<a name="l00265"></a><a class="code" href="classThreadMgr.html#f0">00265</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> *<a class="code" href="classThreadMgr.html#f0">func</a>(<span class="keywordtype">void</span> *arg)
00266   {
00280     <span class="comment">//convenience this object</span>
00281     <a class="code" href="classThreadMgr.html">ThreadMgr</a> *thisObject = ((<span class="keyword">struct </span><a class="code" href="structThreadMgr_1_1func__arguments.html">func_arguments</a> *)arg)-&gt;thisObject;
00282 
00283     <span class="comment">//return argument from user function</span>
00284     <span class="keywordtype">void</span> *tmpArg = NULL;
00285 
00286     <span class="comment">//basic cancel stuff -should be more robust</span>
00287     <span class="keyword">struct </span><a class="code" href="structThreadMgr_1_1func__arguments.html">func_arguments</a> *cancel_arg = <span class="keyword">new</span> <a class="code" href="structThreadMgr_1_1func__arguments.html">func_arguments</a>;
00288     cancel_arg-&gt;cancel_func = <a class="code" href="classThreadMgr.html#f2">shutdown_thread</a>;
00289     cancel_arg-&gt;func = NULL;
00290     cancel_arg-&gt;arg = NULL;
00291     cancel_arg-&gt;thisObject = thisObject;
00292 
00293     <span class="comment">//set the cleanup function</span>
00294     pthread_cleanup_push(<a class="code" href="classThreadMgr.html#f2">shutdown_thread</a>, (<span class="keywordtype">void</span> *)cancel_arg);
00295 
00296     <span class="comment">//call the user's function</span>
00297     tmpArg = ((<span class="keyword">struct </span>func_arguments *)arg)-&gt;func( ((<span class="keyword">struct</span> func_arguments *)arg)-&gt;arg );
00298     <span class="comment">//std::cout &lt;&lt; "func() passing \"" &lt;&lt; *(std::string *)tmpArg &lt;&lt; "\" to pthread_exit()" &lt;&lt; std::endl;</span>
00299 
00300     <span class="comment">//delete (struct func_arguments *)arg;</span>
00301 
00302     <span class="comment">//pop the cleanup handler off the cleanup stack</span>
00303     <span class="comment">//delete the arg variable list from the createThread function.</span>
00304     pthread_cleanup_pop(1);
00305     
00306     <span class="comment">//add this thread to the terminated list</span>
00307     thisObject-&gt;<a class="code" href="classThreadMgr.html#f1">addTerminated</a>(thisObject);
00308 
00309     <span class="comment">//exit this thread</span>
00310     pthread_exit(tmpArg);
00311 
00312     <span class="comment">//we will never get here</span>
00313     <span class="keywordflow">return</span> NULL;
00314   }
00315 
<a name="l00317"></a><a class="code" href="classThreadMgr.html#f1">00317</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> *<a class="code" href="classThreadMgr.html#f1">addTerminated</a>(<a class="code" href="classThreadMgr.html">ThreadMgr</a> *arg)
00318   { 
00319     <span class="comment">//pthread_mutex_lock(((ThreadMgr *)arg)-&gt;m_mutex);</span>
00320     pthread_mutex_lock(arg-&gt;<a class="code" href="classThreadMgr.html#r0">m_mutex</a>);
00321 
00322     <span class="comment">//add self to list of stuff to be terminated (joined)</span>
00323     arg-&gt;<a class="code" href="classThreadMgr.html#r4">m_terminated</a>.push(pthread_self());
00324 
00325     <span class="comment">//broadcast to threads waiting on the condition variable to notify</span>
00326     <span class="comment">//them to wake up</span>
00327     pthread_cond_broadcast(arg-&gt;<a class="code" href="classThreadMgr.html#r2">m_cond_var</a>);
00328 
00329     pthread_mutex_unlock(arg-&gt;<a class="code" href="classThreadMgr.html#r0">m_mutex</a>);
00330 
00331     <span class="comment">//return NULL -blah</span>
00332     <span class="keywordflow">return</span> NULL;
00333   }
00334 
<a name="l00336"></a><a class="code" href="classThreadMgr.html#b0">00336</a>   <span class="keywordtype">int</span> <a class="code" href="classThreadMgr.html#b0">removeTerminated</a>(<span class="keywordtype">void</span> **return_val)
00337   {
00345     <span class="keywordtype">int</span> ret = 0;
00346     pthread_t tempID;
00347 
00348     <span class="comment">//lock critical section</span>
00349     pthread_mutex_lock(<a class="code" href="classThreadMgr.html#r0">m_mutex</a>);
00350 
00351     <span class="comment">//make sure we have something</span>
00352     <span class="keywordflow">if</span>(!<a class="code" href="classThreadMgr.html#r4">m_terminated</a>.empty())
00353       {
00354         <span class="comment">//get id from stack</span>
00355         tempID = <a class="code" href="classThreadMgr.html#r4">m_terminated</a>.top();
00356 
00362         <span class="comment">//join with the terminated thread</span>
00363         <span class="keywordflow">if</span>( (ret = pthread_join(tempID, return_val)) == 0)
00364           {
00365             <span class="comment">//delete the arguments (created in createThread)</span>
00366             <span class="comment">//delete m_ids.find(tempID)-&gt;second;</span>
00367             
00368             <span class="comment">//get rid of the ID from active list</span>
00369             <a class="code" href="classThreadMgr.html#r3">m_ids</a>.erase(tempID);
00370             
00371             <span class="comment">//remove id from stack</span>
00372             <a class="code" href="classThreadMgr.html#r4">m_terminated</a>.pop();
00373           }
00374         <span class="keywordflow">else</span>
00375           std::cout &lt;&lt; <span class="stringliteral">"pthread_join() = "</span> &lt;&lt; ret &lt;&lt; std::endl;
00376       }
00377 
00378     <span class="comment">//unlock critical section</span>
00379     pthread_mutex_unlock(<a class="code" href="classThreadMgr.html#r0">m_mutex</a>);
00380 
00381     <span class="comment">//return value of pthread_join</span>
00382     <span class="keywordflow">return</span> ret;
00383   }
00384 
<a name="l00386"></a><a class="code" href="classThreadMgr.html#b1">00386</a>   <span class="keywordtype">void</span> <a class="code" href="classThreadMgr.html#b1">addID</a>(pthread_t id, <a class="code" href="structThreadMgr_1_1func__arguments.html">func_arguments</a> *arg)
00387   {
00388     <span class="comment">//lock the data mutex</span>
00389     pthread_mutex_lock(<a class="code" href="classThreadMgr.html#r0">m_mutex</a>);
00390     
00391     <span class="comment">//add the thread to the std::map</span>
00392     <a class="code" href="classThreadMgr.html#r3">m_ids</a>.insert(std::make_pair(id, arg));
00393 
00394     <span class="comment">//unlock the data mutex</span>
00395     pthread_mutex_unlock(<a class="code" href="classThreadMgr.html#r0">m_mutex</a>);
00396   }
00397   
<a name="l00399"></a><a class="code" href="classThreadMgr.html#f2">00399</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classThreadMgr.html#f2">shutdown_thread</a>(<span class="keywordtype">void</span> *arg)
00400   {
00403     <span class="keyword">delete</span> ((<span class="keyword">struct </span><a class="code" href="structThreadMgr_1_1func__arguments.html">func_arguments</a> *)arg);
00404     <span class="keywordflow">return</span>;
00405   }
00406 
00407 
00408 <span class="keyword">private</span>:
<a name="l00410"></a><a class="code" href="classThreadMgr.html#r0">00410</a>   pthread_mutex_t *<a class="code" href="classThreadMgr.html#r0">m_mutex</a>;
00411 
<a name="l00413"></a><a class="code" href="classThreadMgr.html#r1">00413</a>   pthread_mutex_t *<a class="code" href="classThreadMgr.html#r1">m_cond_mutex</a>;
00414   
<a name="l00416"></a><a class="code" href="classThreadMgr.html#r2">00416</a>   pthread_cond_t *<a class="code" href="classThreadMgr.html#r2">m_cond_var</a>;
00417 
<a name="l00419"></a><a class="code" href="classThreadMgr.html#r3">00419</a>   std::map&lt;pthread_t, ThreadMgr::func_arguments *&gt; <a class="code" href="classThreadMgr.html#r3">m_ids</a>;
00420 
<a name="l00422"></a><a class="code" href="classThreadMgr.html#r4">00422</a>   std::stack&lt;pthread_t&gt; <a class="code" href="classThreadMgr.html#r4">m_terminated</a>;
00423 };
00424 
00425 
00426 <span class="comment">//################## PROTOTYPES</span>
00428 <span class="comment"></span><span class="keywordtype">void</span> <a class="code" href="threadDeath3_8cc.html#a0">waitStringThreads</a>(<a class="code" href="classThreadMgr.html">ThreadMgr</a> *mgr, <span class="keywordtype">void</span> **return_value);
00429 
00431 <span class="keywordtype">void</span> *<a class="code" href="threadDeath3_8cc.html#a1">myfunc0</a>(<span class="keywordtype">void</span> *arg);
00432 
00434 <span class="keywordtype">void</span> *<a class="code" href="threadDeath3_8cc.html#a2">myfunc1</a>(<span class="keywordtype">void</span> *arg);
00435 
00437 <span class="keywordtype">void</span> *<a class="code" href="threadDeath3_8cc.html#a3">myfunc2</a>(<span class="keywordtype">void</span> *arg);
00438 
00440 <span class="keywordtype">void</span> *<a class="code" href="threadDeath3_8cc.html#a4">myStringFunc</a>(<span class="keywordtype">void</span> *arg);
00441 
00443 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
00444 <span class="keywordtype">void</span> <a class="code" href="threadDeath3_8cc.html#a5">TwaitStringThreads</a>(<a class="code" href="classThreadMgr.html">ThreadMgr</a> *mgr, T return_value);
00445 
00446 <span class="comment">//################## MAIN</span>
<a name="l00448"></a><a class="code" href="threadDeath3_8cc.html#a6">00448</a> <span class="comment"></span><span class="keywordtype">int</span> <a class="code" href="virtuals_8cc.html#a1">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
00449 {
00450   <span class="keywordtype">void</span> **return_val;
00451   <span class="keywordtype">void</span> **ret;
00452 
00453   <span class="comment">//string literal for later use</span>
00454   <span class="keywordtype">char</span> *pc = <span class="stringliteral">"987654321"</span>;
00455 
00456   <span class="comment">//string object of later use (example 2)</span>
00457   std::string *str = <span class="keyword">new</span> std::string(<span class="stringliteral">"a string from main"</span>);
00458 
00459   <span class="comment">//some thread IDs to track</span>
00460   pthread_t pret, pret2;
00461 
00462   <span class="comment">//common variable</span>
00463   <span class="keywordtype">int</span> i = 0;
00464 
00465   <span class="comment">//the thread manager class</span>
00466   <a class="code" href="classThreadMgr.html">ThreadMgr</a> m;
00467 
00468   
00469   <span class="comment">//##########################################################</span>
00470   std::cout &lt;&lt; <span class="stringliteral">"Example 1:"</span> &lt;&lt; std::endl;
00471   <span class="comment">//##########################################################</span>
00472 
00482   <span class="comment">//test the functionality </span>
00483   pret = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a1">myfunc0</a>, NULL);
00484   pret = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a3">myfunc2</a>, (<span class="keywordtype">void</span> *)pc);
00485   pret = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a2">myfunc1</a>, NULL);
00486   pret2 = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a3">myfunc2</a>, (<span class="keywordtype">void</span> *)pc);
00487   pret = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a2">myfunc1</a>, NULL);
00488   pret2 = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a3">myfunc2</a>, (<span class="keywordtype">void</span> *)pc);
00489   pret = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a2">myfunc1</a>, NULL);
00490   pret = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a2">myfunc1</a>, NULL);
00491 
00492   <span class="keywordflow">while</span>(m.<a class="code" href="classThreadMgr.html#a4">threadsActive</a>())
00493     {
00494       <span class="comment">/*do, while there are active threads or there are threads being</span>
00495 <span class="comment">        terminated.</span>
00496 <span class="comment">      */</span>
00497 
00498       <span class="comment">//on the third itteration...</span>
00499       <span class="keywordflow">if</span>(i++ == -1)
00500         {
00501           <span class="comment">//cancel a thread (may lose data this way though!)</span>
00502           std::cout &lt;&lt; <span class="stringliteral">"CANCELING THREAD:"</span> &lt;&lt; pret2 &lt;&lt; std::endl;
00503           m.<a class="code" href="classThreadMgr.html#a1">cancel_thread</a>(&amp;pret2);
00504           
00505           <span class="comment">//create another thread for fun and profit</span>
00506           pret = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a3">myfunc2</a>, (<span class="keywordtype">void</span> *)pc);
00507         }
00508       <span class="keywordflow">else</span>
00509         {
00510           <span class="comment">//wait on the thread</span>
00511           m.<a class="code" href="classThreadMgr.html#a2">condWait</a>(return_val);
00512           <span class="keywordflow">if</span>(*return_val != NULL)
00513             {
00514               std::cout &lt;&lt; <span class="stringliteral">"#######################main:"</span> &lt;&lt; ((<span class="keywordtype">char</span> *)(<span class="keywordtype">char</span> *)*return_val) &lt;&lt; std::endl;
00515 
00516               <span class="comment">/* This cast is not entirely proper. See the next</span>
00517 <span class="comment">                 example for proper casting when deleting this pointer.</span>
00518 <span class="comment">              */</span>
00519               <span class="keyword">delete</span> (<span class="keywordtype">char</span> *)*return_val;
00520             }
00521         }
00522     }
00523 
00524 
00525   <span class="comment">//##########################################################</span>
00526   std::cout &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; <span class="stringliteral">"Example 2:"</span> &lt;&lt; std::endl;
00527   <span class="comment">//##########################################################</span>
00528 
00534   <span class="comment">//test the functionality </span>
00535   pret = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a1">myfunc0</a>, NULL);
00536   pret = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a3">myfunc2</a>, (<span class="keywordtype">void</span> *)pc);
00537   pret = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a2">myfunc1</a>, NULL);
00538   pret2 = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a3">myfunc2</a>, (<span class="keywordtype">void</span> *)pc);
00539   pret = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a2">myfunc1</a>, NULL);
00540   pret2 = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a3">myfunc2</a>, (<span class="keywordtype">void</span> *)pc);
00541   pret = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a2">myfunc1</a>, NULL);
00542   pret = m.<a class="code" href="classThreadMgr.html#a3">createThread</a>((<span class="keywordtype">void</span> *(*)(<span class="keywordtype">void</span> *))<a class="code" href="threadDeath3_8cc.html#a2">myfunc1</a>, NULL);
00543 
00544   <span class="keywordflow">while</span>(m.<a class="code" href="classThreadMgr.html#a4">threadsActive</a>())
00545     {
00546       <span class="comment">/*do, while there are active threads or there are threads being</span>
00547 <span class="comment">        terminated.</span>
00548 <span class="comment">      */</span>
00549 
00550       <span class="comment">//wait on the thread</span>
00551       m.<a class="code" href="classThreadMgr.html#a2">condWait</a>(return_val);
00552 
00553       <span class="comment">/* check return_val: meanwhile other threads may be dieing</span>
00554 <span class="comment">       */</span>
00555       <span class="keywordflow">if</span>(*return_val != NULL)
00556         {
00557           <span class="comment">/* We should get here 3 times from our usage of myfunc2</span>
00558 <span class="comment">             above */</span>
00559           std::cout &lt;&lt; <span class="stringliteral">"#######################main:"</span> &lt;&lt; ((<span class="keywordtype">char</span> *)(<span class="keywordtype">char</span> *)*return_val) &lt;&lt; std::endl;
00560 
00561           <span class="comment">//delete the pointer since it was valid (not NULL)</span>
00562           <span class="keyword">delete</span> ((<span class="keywordtype">char</span> *)(<span class="keywordtype">char</span> *)*return_val);
00563         }
00564     }
00565 
00566 
00567   <span class="comment">//##########################################################</span>
00568   std::cout &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; <span class="stringliteral">"Example 3:"</span> &lt;&lt; std::endl;
00569   <span class="comment">//##########################################################</span>
00570 
00587   <span class="comment">//void **ret;</span>
00588 
00589   <span class="comment">//try to pass an object and get one back</span>
00590   m.<a class="code" href="classThreadMgr.html#a3">createThread</a>(<a class="code" href="threadDeath3_8cc.html#a4">myStringFunc</a>, (<span class="keywordtype">void</span> *)str);
00591 
00592   <span class="comment">//while(m.threadsActive() || !m.no_threads_terminated())</span>
00593   <span class="keywordflow">while</span>(m.<a class="code" href="classThreadMgr.html#a4">threadsActive</a>())
00594     {
00595       <span class="comment">//wait on the thread</span>
00596       m.<a class="code" href="classThreadMgr.html#a2">condWait</a>(ret);
00597       <span class="keywordflow">if</span>(*ret != NULL)
00598         {
00599           <span class="comment">//cast the return_val -contents of a std::string pointer</span>
00600           std::cout &lt;&lt; *((std::string *)(std::string *)*ret) &lt;&lt; std::endl;
00601           
00602           <span class="comment">//delete the memory at the pointer</span>
00603           <span class="keyword">delete</span> ((std::string *)(std::string *)*ret);
00604         }
00605 
00606     }<span class="comment">//end while()</span>
00607   
00608   std::cout &lt;&lt; <span class="stringliteral">"threads Active:"</span> &lt;&lt; m.<a class="code" href="classThreadMgr.html#a4">threadsActive</a>() &lt;&lt; std::endl;
00609   std::cout &lt;&lt; <span class="stringliteral">"no_threads_terminated:"</span> &lt;&lt; m.<a class="code" href="classThreadMgr.html#a5">no_threads_terminated</a>() &lt;&lt; std::endl;
00610 
00611   <span class="comment">//cleanup</span>
00612   <span class="keyword">delete</span> str;
00613 
00614   <span class="comment">//##########################################################</span>
00615   std::cout &lt;&lt; <span class="stringliteral">"\n"</span> &lt;&lt; <span class="stringliteral">"Example 4:"</span> &lt;&lt; std::endl;
00616   <span class="comment">//##########################################################</span>
00617 
00626   <span class="comment">//let's try another instance in tandum</span>
00627   <a class="code" href="classThreadMgr.html">ThreadMgr</a> m1;
00628 
00629   <span class="comment">//create a couple of strings</span>
00630   std::string *str1 = <span class="keyword">new</span> std::string(<span class="stringliteral">"string1 from main"</span>);
00631   std::string *str2 = <span class="keyword">new</span> std::string(<span class="stringliteral">"string2 from main"</span>);
00632 
00633   <span class="comment">//create a thread under m1 instance of ThreadMgr</span>
00634   m1.<a class="code" href="classThreadMgr.html#a3">createThread</a>(<a class="code" href="threadDeath3_8cc.html#a4">myStringFunc</a>, (<span class="keywordtype">void</span> *)str1);
00635 
00636   <span class="comment">//create a thread under m instance of ThreadMgr</span>
00637   m.<a class="code" href="classThreadMgr.html#a3">createThread</a>(<a class="code" href="threadDeath3_8cc.html#a4">myStringFunc</a>, (<span class="keywordtype">void</span> *)str2);
00638 
00639 
00640   <span class="comment">//manage threads from m instance of ThreadMgr</span>
00641   <a class="code" href="threadDeath3_8cc.html#a0">waitStringThreads</a>(&amp;m, ret);
00642 
00643   <span class="comment">//manage threads from m1 instance of ThreadMgr</span>
00644   <a class="code" href="threadDeath3_8cc.html#a5">TwaitStringThreads</a>(&amp;m1, (std::string **)ret);
00645 
00646   
00647   <span class="comment">//cleanup</span>
00648   <span class="comment">//delete str1;</span>
00649   <span class="keyword">delete</span> str2;
00650   
00651   <span class="comment">//exit normally</span>
00652   <span class="keywordflow">return</span>(0);
00653 }
00654 
<a name="l00656"></a><a class="code" href="threadDeath3_8cc.html#a0">00656</a> <span class="keywordtype">void</span> <a class="code" href="threadDeath3_8cc.html#a0">waitStringThreads</a>(<a class="code" href="classThreadMgr.html">ThreadMgr</a> *mgr, <span class="keywordtype">void</span> **return_value)
00657 {
00686   <span class="comment">//void **return_value;                // doesn't work !!!!</span>
00687 
00688   <span class="keywordflow">while</span>(mgr-&gt;<a class="code" href="classThreadMgr.html#a4">threadsActive</a>())
00689     {
00690       <span class="comment">//wait on the thread</span>
00691       mgr-&gt;<a class="code" href="classThreadMgr.html#a2">condWait</a>((<span class="keywordtype">void</span> **)return_value);
00692 
00693       <span class="keywordflow">if</span>(*return_value != NULL)
00694         {
00695           <span class="comment">//cast the return_val -contents of a std::string pointer</span>
00696           std::cout &lt;&lt; <span class="stringliteral">"waitStringThreads:"</span> &lt;&lt; *((std::string *)(std::string *)*return_value) &lt;&lt; std::endl;
00697           
00698           <span class="comment">//delete the memory at the pointer</span>
00699           <span class="keyword">delete</span> ((std::string *)(std::string *)*return_value);
00700         }
00701     }<span class="comment">//end while()</span>
00702 }
00703 
00722 <span class="keyword">template</span> &lt;<span class="keyword">class</span> T&gt;
<a name="l00723"></a><a class="code" href="threadDeath3_8cc.html#a5">00723</a> <span class="keywordtype">void</span> <a class="code" href="threadDeath3_8cc.html#a5">TwaitStringThreads</a>(<a class="code" href="classThreadMgr.html">ThreadMgr</a> *mgr, T return_value)
00724 {
00725   <span class="keywordflow">while</span>(mgr-&gt;<a class="code" href="classThreadMgr.html#a4">threadsActive</a>())
00726     {
00727       <span class="comment">//wait on the thread</span>
00728       mgr-&gt;<a class="code" href="classThreadMgr.html#a2">condWait</a>((<span class="keywordtype">void</span> **)return_value);
00729 
00730       <span class="keywordflow">if</span>(*return_value != NULL)
00731         {
00732           <span class="comment">//cast the return_val -contents of a T pointer</span>
00733 
00734           <span class="comment">/* if we pass in a string ** then this translates to: </span>
00735 <span class="comment">          **(string **)return_value for the call to cout. remember, if</span>
00736 <span class="comment">          return_value is a pointer to an object then we want the</span>
00737 <span class="comment">          contents of the pointed to item of the pointer (it's a pointer</span>
00738 <span class="comment">          to a pointer to a pointer to something)</span>
00739 <span class="comment">          */</span>
00740           std::cout &lt;&lt; <span class="stringliteral">"TwaitStringThreads:"</span> &lt;&lt; **((T)return_value) &lt;&lt; std::endl;
00741           
00742           <span class="comment">//delete the memory at the pointer</span>
00743           <span class="keyword">delete</span> *return_value;
00744         }
00745     }<span class="comment">//end while()</span>
00746 }
00747 
<a name="l00758"></a><a class="code" href="threadDeath3_8cc.html#a4">00758</a> <span class="keywordtype">void</span> *<a class="code" href="threadDeath3_8cc.html#a4">myStringFunc</a>(<span class="keywordtype">void</span> *arg)
00759 {
00760   <span class="comment">//copy the string using casts</span>
00761   <span class="comment">//std::string *a = ((std::string *)arg);</span>
00762   <span class="comment">//std::cout &lt;&lt; "myStringFunc printing:" &lt;&lt; *a &lt;&lt; std::endl;</span>
00763 
00764   <span class="comment">//print the contents of arg as an std::string pointer</span>
00765   std::cout &lt;&lt; <span class="stringliteral">"myStringFunc printing:"</span> &lt;&lt; *(std::string *)arg &lt;&lt; std::endl;
00766   
00767   <span class="comment">//create a new string to be returned to the calling thread</span>
00768   std::string *s = <span class="keyword">new</span> std::string(<span class="stringliteral">"a string from myStringFunc"</span>);
00769   std::cout &lt;&lt; <span class="stringliteral">"myStringFunc returning:"</span> &lt;&lt; *s &lt;&lt; std::endl;
00770 
00771   <span class="comment">//cast the object as a void pointer and return</span>
00772   <span class="keywordflow">return</span> ((<span class="keywordtype">void</span> *)s);
00773 
00774   <span class="comment">//return ((void *)NULL);</span>
00775 }
00776 
<a name="l00781"></a><a class="code" href="threadDeath3_8cc.html#a1">00781</a> <span class="keywordtype">void</span> *<a class="code" href="threadDeath3_8cc.html#a1">myfunc0</a>(<span class="keywordtype">void</span> *arg)
00782 {
00783   std::cout &lt;&lt; <span class="stringliteral">"got here: myfunc0:BEGIN"</span> &lt;&lt; std::endl;
00784 
00785   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=10000; i &gt; 0; i--)
00786     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=10000; i &gt; 0; i--);
00787 
00788   std::cout &lt;&lt; <span class="stringliteral">"got here: myfunc0:END"</span> &lt;&lt; std::endl;
00789 
00790   <span class="keywordflow">return</span> NULL; 
00791 }
00792 
<a name="l00798"></a><a class="code" href="threadDeath3_8cc.html#a2">00798</a> <span class="keywordtype">void</span> *<a class="code" href="threadDeath3_8cc.html#a2">myfunc1</a>(<span class="keywordtype">void</span> *arg)
00799 {
00800   std::cout &lt;&lt; <span class="stringliteral">"got here: myfunc1:BEGIN"</span> &lt;&lt; std::endl;
00801 
00802   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=1000; i &gt; 0; i--)
00803     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=10000; i &gt; 0; i--);
00804 
00805   std::cout &lt;&lt; <span class="stringliteral">"got here: myfunc1:END"</span> &lt;&lt; std::endl;
00806 
00807   <span class="keywordflow">return</span> NULL; 
00808 }
00809 
<a name="l00819"></a><a class="code" href="threadDeath3_8cc.html#a3">00819</a> <span class="keywordtype">void</span> *<a class="code" href="threadDeath3_8cc.html#a3">myfunc2</a>(<span class="keywordtype">void</span> *arg)
00820 {
00821   std::cout &lt;&lt; <span class="stringliteral">"got here: myfunc2:BEGIN"</span> &lt;&lt; std::endl;
00822 
00823   <span class="comment">//print the value of arg from main</span>
00824   std::cout &lt;&lt; <span class="stringliteral">"|arg = "</span> &lt;&lt; (<span class="keywordtype">char</span> *)arg &lt;&lt; std::endl;
00825 
00826   <span class="comment">//create a new char and add data to the memory area</span>
00827   <span class="keywordtype">char</span> *tmp = <span class="keyword">new</span> <span class="keywordtype">char</span>[10];
00828   <span class="keywordtype">char</span> x[10] = {<span class="stringliteral">"123456789"</span>};
00829 
00830   <span class="comment">//cheezy, but whatever...</span>
00831   memcpy(tmp, x, 10);
00832 
00833   std::cout &lt;&lt; <span class="stringliteral">"myfunc2:"</span> &lt;&lt; tmp &lt;&lt; std::endl;
00834 
00835   <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=10000; i &gt; 0; i--)
00836     <span class="keywordflow">for</span>(<span class="keywordtype">int</span> i=10000; i &gt; 0; i--);
00837 
00838   std::cout &lt;&lt; <span class="stringliteral">"got here: myfunc2:END"</span> &lt;&lt; std::endl;
00839 
00844   <span class="keywordflow">return</span> tmp;
00845 }
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Tue Jun 15 03:48:57 2004 for Various C++ Examples (including IPC) by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 > 
</a>1.3.5 </small></address>
</body>
</html>
